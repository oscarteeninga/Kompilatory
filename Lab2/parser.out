Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BREAK
    CONTINUE
    ELSE
    EQORGT
    EQORLESS
    EQUAL
    FOR
    IF
    NOTEQUAL
    RETURN
    STRING
    WHILE

Grammar

Rule 0     S' -> EXPRESSION
Rule 1     EXPRESSION -> TERM
Rule 2     EXPRESSION -> EXPRESSION TERM
Rule 3     TERM -> STATEMENT
Rule 4     TERM -> PRINT
Rule 5     VAR -> NUM
Rule 6     VAR -> MATRIX
Rule 7     NUM -> INTNUM
Rule 8     NUM -> FLOATNUM
Rule 9     VECTOR -> VECTOR , NUM
Rule 10    VECTOR -> NUM
Rule 11    VECTORS -> VECTORS ; VECTOR
Rule 12    VECTORS -> VECTOR
Rule 13    MATRIX -> [ VECTORS ]
Rule 14    MATRIX -> ZEROS ( INTNUM )
Rule 15    MATRIX -> ONES ( INTNUM )
Rule 16    MATRIX -> EYE ( INTNUM )
Rule 17    MATRIX -> - ID
Rule 18    MATRIX -> ID '
Rule 19    VAR -> ID + ID
Rule 20    VAR -> ID - ID
Rule 21    VAR -> ID * ID
Rule 22    VAR -> ID / ID
Rule 23    MATRIX -> ID DOTADD ID
Rule 24    MATRIX -> ID DOTSUB ID
Rule 25    MATRIX -> ID DOTMUL ID
Rule 26    MATRIX -> ID DOTDIV ID
Rule 27    STATEMENT -> ID = VAR ;
Rule 28    STATEMENT -> ID [ INTNUM , INTNUM ] = NUM ;
Rule 29    STATEMENT -> ID ADDASSIGN ID ;
Rule 30    STATEMENT -> ID SUBASSIGN ID ;
Rule 31    STATEMENT -> ID MULASSIGN ID ;
Rule 32    STATEMENT -> ID DIVASSIGN ID ;
Rule 33    TERM -> PRINT ( ID ) ;
Rule 34    TERM -> PRINT ( VAR ) ;

Terminals, with rules where they appear

'                    : 18
(                    : 14 15 16 33 34
)                    : 14 15 16 33 34
*                    : 21
+                    : 19
,                    : 9 28
-                    : 17 20
/                    : 22
;                    : 11 27 28 29 30 31 32 33 34
=                    : 27 28
ADDASSIGN            : 29
BREAK                : 
CONTINUE             : 
DIVASSIGN            : 32
DOTADD               : 23
DOTDIV               : 26
DOTMUL               : 25
DOTSUB               : 24
ELSE                 : 
EQORGT               : 
EQORLESS             : 
EQUAL                : 
EYE                  : 16
FLOATNUM             : 8
FOR                  : 
ID                   : 17 18 19 19 20 20 21 21 22 22 23 23 24 24 25 25 26 26 27 28 29 29 30 30 31 31 32 32 33
IF                   : 
INTNUM               : 7 14 15 16 28 28
MULASSIGN            : 31
NOTEQUAL             : 
ONES                 : 15
PRINT                : 4 33 34
RETURN               : 
STRING               : 
SUBASSIGN            : 30
WHILE                : 
ZEROS                : 14
[                    : 13 28
]                    : 13 28
error                : 

Nonterminals, with rules where they appear

EXPRESSION           : 2 0
MATRIX               : 6
NUM                  : 5 9 10 28
STATEMENT            : 3
TERM                 : 1 2
VAR                  : 27 34
VECTOR               : 9 11 12
VECTORS              : 11 13

Parsing method: LALR

state 0

    (0) S' -> . EXPRESSION
    (1) EXPRESSION -> . TERM
    (2) EXPRESSION -> . EXPRESSION TERM
    (3) TERM -> . STATEMENT
    (4) TERM -> . PRINT
    (33) TERM -> . PRINT ( ID ) ;
    (34) TERM -> . PRINT ( VAR ) ;
    (27) STATEMENT -> . ID = VAR ;
    (28) STATEMENT -> . ID [ INTNUM , INTNUM ] = NUM ;
    (29) STATEMENT -> . ID ADDASSIGN ID ;
    (30) STATEMENT -> . ID SUBASSIGN ID ;
    (31) STATEMENT -> . ID MULASSIGN ID ;
    (32) STATEMENT -> . ID DIVASSIGN ID ;

    PRINT           shift and go to state 4
    ID              shift and go to state 5

    EXPRESSION                     shift and go to state 1
    TERM                           shift and go to state 2
    STATEMENT                      shift and go to state 3

state 1

    (0) S' -> EXPRESSION .
    (2) EXPRESSION -> EXPRESSION . TERM
    (3) TERM -> . STATEMENT
    (4) TERM -> . PRINT
    (33) TERM -> . PRINT ( ID ) ;
    (34) TERM -> . PRINT ( VAR ) ;
    (27) STATEMENT -> . ID = VAR ;
    (28) STATEMENT -> . ID [ INTNUM , INTNUM ] = NUM ;
    (29) STATEMENT -> . ID ADDASSIGN ID ;
    (30) STATEMENT -> . ID SUBASSIGN ID ;
    (31) STATEMENT -> . ID MULASSIGN ID ;
    (32) STATEMENT -> . ID DIVASSIGN ID ;

    PRINT           shift and go to state 4
    ID              shift and go to state 5

    TERM                           shift and go to state 6
    STATEMENT                      shift and go to state 3

state 2

    (1) EXPRESSION -> TERM .

    PRINT           reduce using rule 1 (EXPRESSION -> TERM .)
    ID              reduce using rule 1 (EXPRESSION -> TERM .)
    $end            reduce using rule 1 (EXPRESSION -> TERM .)


state 3

    (3) TERM -> STATEMENT .

    PRINT           reduce using rule 3 (TERM -> STATEMENT .)
    ID              reduce using rule 3 (TERM -> STATEMENT .)
    $end            reduce using rule 3 (TERM -> STATEMENT .)


state 4

    (4) TERM -> PRINT .
    (33) TERM -> PRINT . ( ID ) ;
    (34) TERM -> PRINT . ( VAR ) ;

    PRINT           reduce using rule 4 (TERM -> PRINT .)
    ID              reduce using rule 4 (TERM -> PRINT .)
    $end            reduce using rule 4 (TERM -> PRINT .)
    (               shift and go to state 7


state 5

    (27) STATEMENT -> ID . = VAR ;
    (28) STATEMENT -> ID . [ INTNUM , INTNUM ] = NUM ;
    (29) STATEMENT -> ID . ADDASSIGN ID ;
    (30) STATEMENT -> ID . SUBASSIGN ID ;
    (31) STATEMENT -> ID . MULASSIGN ID ;
    (32) STATEMENT -> ID . DIVASSIGN ID ;

    =               shift and go to state 8
    [               shift and go to state 9
    ADDASSIGN       shift and go to state 10
    SUBASSIGN       shift and go to state 11
    MULASSIGN       shift and go to state 12
    DIVASSIGN       shift and go to state 13


state 6

    (2) EXPRESSION -> EXPRESSION TERM .

    PRINT           reduce using rule 2 (EXPRESSION -> EXPRESSION TERM .)
    ID              reduce using rule 2 (EXPRESSION -> EXPRESSION TERM .)
    $end            reduce using rule 2 (EXPRESSION -> EXPRESSION TERM .)


state 7

    (33) TERM -> PRINT ( . ID ) ;
    (34) TERM -> PRINT ( . VAR ) ;
    (5) VAR -> . NUM
    (6) VAR -> . MATRIX
    (19) VAR -> . ID + ID
    (20) VAR -> . ID - ID
    (21) VAR -> . ID * ID
    (22) VAR -> . ID / ID
    (7) NUM -> . INTNUM
    (8) NUM -> . FLOATNUM
    (13) MATRIX -> . [ VECTORS ]
    (14) MATRIX -> . ZEROS ( INTNUM )
    (15) MATRIX -> . ONES ( INTNUM )
    (16) MATRIX -> . EYE ( INTNUM )
    (17) MATRIX -> . - ID
    (18) MATRIX -> . ID '
    (23) MATRIX -> . ID DOTADD ID
    (24) MATRIX -> . ID DOTSUB ID
    (25) MATRIX -> . ID DOTMUL ID
    (26) MATRIX -> . ID DOTDIV ID

    ID              shift and go to state 14
    INTNUM          shift and go to state 19
    FLOATNUM        shift and go to state 20
    [               shift and go to state 21
    ZEROS           shift and go to state 22
    ONES            shift and go to state 23
    EYE             shift and go to state 24
    -               shift and go to state 18

    VAR                            shift and go to state 15
    NUM                            shift and go to state 16
    MATRIX                         shift and go to state 17

state 8

    (27) STATEMENT -> ID = . VAR ;
    (5) VAR -> . NUM
    (6) VAR -> . MATRIX
    (19) VAR -> . ID + ID
    (20) VAR -> . ID - ID
    (21) VAR -> . ID * ID
    (22) VAR -> . ID / ID
    (7) NUM -> . INTNUM
    (8) NUM -> . FLOATNUM
    (13) MATRIX -> . [ VECTORS ]
    (14) MATRIX -> . ZEROS ( INTNUM )
    (15) MATRIX -> . ONES ( INTNUM )
    (16) MATRIX -> . EYE ( INTNUM )
    (17) MATRIX -> . - ID
    (18) MATRIX -> . ID '
    (23) MATRIX -> . ID DOTADD ID
    (24) MATRIX -> . ID DOTSUB ID
    (25) MATRIX -> . ID DOTMUL ID
    (26) MATRIX -> . ID DOTDIV ID

    ID              shift and go to state 25
    INTNUM          shift and go to state 19
    FLOATNUM        shift and go to state 20
    [               shift and go to state 21
    ZEROS           shift and go to state 22
    ONES            shift and go to state 23
    EYE             shift and go to state 24
    -               shift and go to state 18

    VAR                            shift and go to state 26
    NUM                            shift and go to state 16
    MATRIX                         shift and go to state 17

state 9

    (28) STATEMENT -> ID [ . INTNUM , INTNUM ] = NUM ;

    INTNUM          shift and go to state 27


state 10

    (29) STATEMENT -> ID ADDASSIGN . ID ;

    ID              shift and go to state 28


state 11

    (30) STATEMENT -> ID SUBASSIGN . ID ;

    ID              shift and go to state 29


state 12

    (31) STATEMENT -> ID MULASSIGN . ID ;

    ID              shift and go to state 30


state 13

    (32) STATEMENT -> ID DIVASSIGN . ID ;

    ID              shift and go to state 31


state 14

    (33) TERM -> PRINT ( ID . ) ;
    (19) VAR -> ID . + ID
    (20) VAR -> ID . - ID
    (21) VAR -> ID . * ID
    (22) VAR -> ID . / ID
    (18) MATRIX -> ID . '
    (23) MATRIX -> ID . DOTADD ID
    (24) MATRIX -> ID . DOTSUB ID
    (25) MATRIX -> ID . DOTMUL ID
    (26) MATRIX -> ID . DOTDIV ID

    )               shift and go to state 32
    +               shift and go to state 33
    -               shift and go to state 34
    *               shift and go to state 35
    /               shift and go to state 36
    '               shift and go to state 37
    DOTADD          shift and go to state 38
    DOTSUB          shift and go to state 39
    DOTMUL          shift and go to state 40
    DOTDIV          shift and go to state 41


state 15

    (34) TERM -> PRINT ( VAR . ) ;

    )               shift and go to state 42


state 16

    (5) VAR -> NUM .

    )               reduce using rule 5 (VAR -> NUM .)
    ;               reduce using rule 5 (VAR -> NUM .)


state 17

    (6) VAR -> MATRIX .

    )               reduce using rule 6 (VAR -> MATRIX .)
    ;               reduce using rule 6 (VAR -> MATRIX .)


state 18

    (17) MATRIX -> - . ID

    ID              shift and go to state 43


state 19

    (7) NUM -> INTNUM .

    )               reduce using rule 7 (NUM -> INTNUM .)
    ;               reduce using rule 7 (NUM -> INTNUM .)
    ,               reduce using rule 7 (NUM -> INTNUM .)
    ]               reduce using rule 7 (NUM -> INTNUM .)


state 20

    (8) NUM -> FLOATNUM .

    )               reduce using rule 8 (NUM -> FLOATNUM .)
    ;               reduce using rule 8 (NUM -> FLOATNUM .)
    ,               reduce using rule 8 (NUM -> FLOATNUM .)
    ]               reduce using rule 8 (NUM -> FLOATNUM .)


state 21

    (13) MATRIX -> [ . VECTORS ]
    (11) VECTORS -> . VECTORS ; VECTOR
    (12) VECTORS -> . VECTOR
    (9) VECTOR -> . VECTOR , NUM
    (10) VECTOR -> . NUM
    (7) NUM -> . INTNUM
    (8) NUM -> . FLOATNUM

    INTNUM          shift and go to state 19
    FLOATNUM        shift and go to state 20

    VECTORS                        shift and go to state 44
    VECTOR                         shift and go to state 45
    NUM                            shift and go to state 46

state 22

    (14) MATRIX -> ZEROS . ( INTNUM )

    (               shift and go to state 47


state 23

    (15) MATRIX -> ONES . ( INTNUM )

    (               shift and go to state 48


state 24

    (16) MATRIX -> EYE . ( INTNUM )

    (               shift and go to state 49


state 25

    (19) VAR -> ID . + ID
    (20) VAR -> ID . - ID
    (21) VAR -> ID . * ID
    (22) VAR -> ID . / ID
    (18) MATRIX -> ID . '
    (23) MATRIX -> ID . DOTADD ID
    (24) MATRIX -> ID . DOTSUB ID
    (25) MATRIX -> ID . DOTMUL ID
    (26) MATRIX -> ID . DOTDIV ID

    +               shift and go to state 33
    -               shift and go to state 34
    *               shift and go to state 35
    /               shift and go to state 36
    '               shift and go to state 37
    DOTADD          shift and go to state 38
    DOTSUB          shift and go to state 39
    DOTMUL          shift and go to state 40
    DOTDIV          shift and go to state 41


state 26

    (27) STATEMENT -> ID = VAR . ;

    ;               shift and go to state 50


state 27

    (28) STATEMENT -> ID [ INTNUM . , INTNUM ] = NUM ;

    ,               shift and go to state 51


state 28

    (29) STATEMENT -> ID ADDASSIGN ID . ;

    ;               shift and go to state 52


state 29

    (30) STATEMENT -> ID SUBASSIGN ID . ;

    ;               shift and go to state 53


state 30

    (31) STATEMENT -> ID MULASSIGN ID . ;

    ;               shift and go to state 54


state 31

    (32) STATEMENT -> ID DIVASSIGN ID . ;

    ;               shift and go to state 55


state 32

    (33) TERM -> PRINT ( ID ) . ;

    ;               shift and go to state 56


state 33

    (19) VAR -> ID + . ID

    ID              shift and go to state 57


state 34

    (20) VAR -> ID - . ID

    ID              shift and go to state 58


state 35

    (21) VAR -> ID * . ID

    ID              shift and go to state 59


state 36

    (22) VAR -> ID / . ID

    ID              shift and go to state 60


state 37

    (18) MATRIX -> ID ' .

    )               reduce using rule 18 (MATRIX -> ID ' .)
    ;               reduce using rule 18 (MATRIX -> ID ' .)


state 38

    (23) MATRIX -> ID DOTADD . ID

    ID              shift and go to state 61


state 39

    (24) MATRIX -> ID DOTSUB . ID

    ID              shift and go to state 62


state 40

    (25) MATRIX -> ID DOTMUL . ID

    ID              shift and go to state 63


state 41

    (26) MATRIX -> ID DOTDIV . ID

    ID              shift and go to state 64


state 42

    (34) TERM -> PRINT ( VAR ) . ;

    ;               shift and go to state 65


state 43

    (17) MATRIX -> - ID .

    )               reduce using rule 17 (MATRIX -> - ID .)
    ;               reduce using rule 17 (MATRIX -> - ID .)


state 44

    (13) MATRIX -> [ VECTORS . ]
    (11) VECTORS -> VECTORS . ; VECTOR

    ]               shift and go to state 66
    ;               shift and go to state 67


state 45

    (12) VECTORS -> VECTOR .
    (9) VECTOR -> VECTOR . , NUM

    ]               reduce using rule 12 (VECTORS -> VECTOR .)
    ;               reduce using rule 12 (VECTORS -> VECTOR .)
    ,               shift and go to state 68


state 46

    (10) VECTOR -> NUM .

    ,               reduce using rule 10 (VECTOR -> NUM .)
    ]               reduce using rule 10 (VECTOR -> NUM .)
    ;               reduce using rule 10 (VECTOR -> NUM .)


state 47

    (14) MATRIX -> ZEROS ( . INTNUM )

    INTNUM          shift and go to state 69


state 48

    (15) MATRIX -> ONES ( . INTNUM )

    INTNUM          shift and go to state 70


state 49

    (16) MATRIX -> EYE ( . INTNUM )

    INTNUM          shift and go to state 71


state 50

    (27) STATEMENT -> ID = VAR ; .

    PRINT           reduce using rule 27 (STATEMENT -> ID = VAR ; .)
    ID              reduce using rule 27 (STATEMENT -> ID = VAR ; .)
    $end            reduce using rule 27 (STATEMENT -> ID = VAR ; .)


state 51

    (28) STATEMENT -> ID [ INTNUM , . INTNUM ] = NUM ;

    INTNUM          shift and go to state 72


state 52

    (29) STATEMENT -> ID ADDASSIGN ID ; .

    PRINT           reduce using rule 29 (STATEMENT -> ID ADDASSIGN ID ; .)
    ID              reduce using rule 29 (STATEMENT -> ID ADDASSIGN ID ; .)
    $end            reduce using rule 29 (STATEMENT -> ID ADDASSIGN ID ; .)


state 53

    (30) STATEMENT -> ID SUBASSIGN ID ; .

    PRINT           reduce using rule 30 (STATEMENT -> ID SUBASSIGN ID ; .)
    ID              reduce using rule 30 (STATEMENT -> ID SUBASSIGN ID ; .)
    $end            reduce using rule 30 (STATEMENT -> ID SUBASSIGN ID ; .)


state 54

    (31) STATEMENT -> ID MULASSIGN ID ; .

    PRINT           reduce using rule 31 (STATEMENT -> ID MULASSIGN ID ; .)
    ID              reduce using rule 31 (STATEMENT -> ID MULASSIGN ID ; .)
    $end            reduce using rule 31 (STATEMENT -> ID MULASSIGN ID ; .)


state 55

    (32) STATEMENT -> ID DIVASSIGN ID ; .

    PRINT           reduce using rule 32 (STATEMENT -> ID DIVASSIGN ID ; .)
    ID              reduce using rule 32 (STATEMENT -> ID DIVASSIGN ID ; .)
    $end            reduce using rule 32 (STATEMENT -> ID DIVASSIGN ID ; .)


state 56

    (33) TERM -> PRINT ( ID ) ; .

    PRINT           reduce using rule 33 (TERM -> PRINT ( ID ) ; .)
    ID              reduce using rule 33 (TERM -> PRINT ( ID ) ; .)
    $end            reduce using rule 33 (TERM -> PRINT ( ID ) ; .)


state 57

    (19) VAR -> ID + ID .

    )               reduce using rule 19 (VAR -> ID + ID .)
    ;               reduce using rule 19 (VAR -> ID + ID .)


state 58

    (20) VAR -> ID - ID .

    )               reduce using rule 20 (VAR -> ID - ID .)
    ;               reduce using rule 20 (VAR -> ID - ID .)


state 59

    (21) VAR -> ID * ID .

    )               reduce using rule 21 (VAR -> ID * ID .)
    ;               reduce using rule 21 (VAR -> ID * ID .)


state 60

    (22) VAR -> ID / ID .

    )               reduce using rule 22 (VAR -> ID / ID .)
    ;               reduce using rule 22 (VAR -> ID / ID .)


state 61

    (23) MATRIX -> ID DOTADD ID .

    )               reduce using rule 23 (MATRIX -> ID DOTADD ID .)
    ;               reduce using rule 23 (MATRIX -> ID DOTADD ID .)


state 62

    (24) MATRIX -> ID DOTSUB ID .

    )               reduce using rule 24 (MATRIX -> ID DOTSUB ID .)
    ;               reduce using rule 24 (MATRIX -> ID DOTSUB ID .)


state 63

    (25) MATRIX -> ID DOTMUL ID .

    )               reduce using rule 25 (MATRIX -> ID DOTMUL ID .)
    ;               reduce using rule 25 (MATRIX -> ID DOTMUL ID .)


state 64

    (26) MATRIX -> ID DOTDIV ID .

    )               reduce using rule 26 (MATRIX -> ID DOTDIV ID .)
    ;               reduce using rule 26 (MATRIX -> ID DOTDIV ID .)


state 65

    (34) TERM -> PRINT ( VAR ) ; .

    PRINT           reduce using rule 34 (TERM -> PRINT ( VAR ) ; .)
    ID              reduce using rule 34 (TERM -> PRINT ( VAR ) ; .)
    $end            reduce using rule 34 (TERM -> PRINT ( VAR ) ; .)


state 66

    (13) MATRIX -> [ VECTORS ] .

    )               reduce using rule 13 (MATRIX -> [ VECTORS ] .)
    ;               reduce using rule 13 (MATRIX -> [ VECTORS ] .)


state 67

    (11) VECTORS -> VECTORS ; . VECTOR
    (9) VECTOR -> . VECTOR , NUM
    (10) VECTOR -> . NUM
    (7) NUM -> . INTNUM
    (8) NUM -> . FLOATNUM

    INTNUM          shift and go to state 19
    FLOATNUM        shift and go to state 20

    VECTOR                         shift and go to state 73
    NUM                            shift and go to state 46

state 68

    (9) VECTOR -> VECTOR , . NUM
    (7) NUM -> . INTNUM
    (8) NUM -> . FLOATNUM

    INTNUM          shift and go to state 19
    FLOATNUM        shift and go to state 20

    NUM                            shift and go to state 74

state 69

    (14) MATRIX -> ZEROS ( INTNUM . )

    )               shift and go to state 75


state 70

    (15) MATRIX -> ONES ( INTNUM . )

    )               shift and go to state 76


state 71

    (16) MATRIX -> EYE ( INTNUM . )

    )               shift and go to state 77


state 72

    (28) STATEMENT -> ID [ INTNUM , INTNUM . ] = NUM ;

    ]               shift and go to state 78


state 73

    (11) VECTORS -> VECTORS ; VECTOR .
    (9) VECTOR -> VECTOR . , NUM

    ]               reduce using rule 11 (VECTORS -> VECTORS ; VECTOR .)
    ;               reduce using rule 11 (VECTORS -> VECTORS ; VECTOR .)
    ,               shift and go to state 68


state 74

    (9) VECTOR -> VECTOR , NUM .

    ,               reduce using rule 9 (VECTOR -> VECTOR , NUM .)
    ]               reduce using rule 9 (VECTOR -> VECTOR , NUM .)
    ;               reduce using rule 9 (VECTOR -> VECTOR , NUM .)


state 75

    (14) MATRIX -> ZEROS ( INTNUM ) .

    )               reduce using rule 14 (MATRIX -> ZEROS ( INTNUM ) .)
    ;               reduce using rule 14 (MATRIX -> ZEROS ( INTNUM ) .)


state 76

    (15) MATRIX -> ONES ( INTNUM ) .

    )               reduce using rule 15 (MATRIX -> ONES ( INTNUM ) .)
    ;               reduce using rule 15 (MATRIX -> ONES ( INTNUM ) .)


state 77

    (16) MATRIX -> EYE ( INTNUM ) .

    )               reduce using rule 16 (MATRIX -> EYE ( INTNUM ) .)
    ;               reduce using rule 16 (MATRIX -> EYE ( INTNUM ) .)


state 78

    (28) STATEMENT -> ID [ INTNUM , INTNUM ] . = NUM ;

    =               shift and go to state 79


state 79

    (28) STATEMENT -> ID [ INTNUM , INTNUM ] = . NUM ;
    (7) NUM -> . INTNUM
    (8) NUM -> . FLOATNUM

    INTNUM          shift and go to state 19
    FLOATNUM        shift and go to state 20

    NUM                            shift and go to state 80

state 80

    (28) STATEMENT -> ID [ INTNUM , INTNUM ] = NUM . ;

    ;               shift and go to state 81


state 81

    (28) STATEMENT -> ID [ INTNUM , INTNUM ] = NUM ; .

    PRINT           reduce using rule 28 (STATEMENT -> ID [ INTNUM , INTNUM ] = NUM ; .)
    ID              reduce using rule 28 (STATEMENT -> ID [ INTNUM , INTNUM ] = NUM ; .)
    $end            reduce using rule 28 (STATEMENT -> ID [ INTNUM , INTNUM ] = NUM ; .)

